## 基本UDP套接字编程
----

#### 1. client.cpp
----
`dg_cli`函数负责从标准输入读取数据，并通过`sendto`发送至服务器端，成功后再用`recvfrom`从服务器端读取数据

#### 2. client1.cpp
----
由于在**client.cpp**中并没有对接收到消息的对端是否是服务器做出判断, 所以从recvfrom中读到的消息可能并非服务器所发，所以**client1.cpp**中的`dg_cli`对此作了改进：

- 传建一个地址结构体用来存储对端的IP地址和端口地址
- 在`recvfrom`中将参数的地址传入
- 在`recvfrom`成功返回之后，首先根据大小判断该套接字地址结构体与服务器套接字地址结构体是否相同，其次判断两个结构体是否相同
  
#### 3. 数据报的丢失
----
  在client中发送数据报之后，就进行读操作检测是否有服务器发来的数据报，这其中会出现两种情况：
    
   1. 当客户数据报在发往服务器的途中丢失，客户将永远阻塞在`recvfrom`调用中
   2. 如果服务器发来的应答在途中丢失，客户也将永远阻塞在`recvfrom`调用中
  
  为了防止这种情况的发生，一般方法是对recvfrom设置一个超时，但是如果只有超时是无法判断出是以上两种原因中的哪一个造成的，待续。。。

#### 4. 服务器未运行
----
1. `sendto`函数调用引发了一个ICMP消息（端口不可达），但是这个错误不会返回给当前进程
2. `sendto`函数调用本身是成功的，这只表示接口输出队列中具备存放所形成的IP数据报的空间
3. ICMP数据报直到后来才返回（4ms之后），称之为**异步错误**
4. 此应答返回时，进程阻塞在`recvfrom`上，但错误并非`recvfrom`引发
5. 如果`sendto`同时发送多个消息，有其中一个出现服务器未运行，将无法知道是哪一个消息引发该ICMP错误
6. 原因是，`recvfrom`收到的错误只有errno值，没办法找到出错数据报的目的IP和目的UDP端口

**总结：**

1. 仅在进程将其UDP套接字连接到一个对端后，这些异步错误才会返回给进程
2. 客户可以调用`bind`指定自己的ip和port，但是如果选择使用临时端口，那端口号会在第一次调用`sendto`时由内核决定，不能改变
3. 如果客户主机是多宿的，那么客户的IP地址会随着数据报的不同而变动
4. 对于UDP服务器来说，想要获得客户端的目的IP地址，只能通过为IPv4设置`IP_RECVDSTADDR`套接字选项（或者IPv6设置`IPV6_PKTINFO`），再调用`recvmsg`
5. 想要获得客户端的目的端口号，可以调用`getsockname`



#### 5. 服务器可以从到达的IP数据报报中获取的信息
----
|来自客户的IP数据报|TCP服务器  |UDP服务器  |
|:-----|:------:|--:|
|源IP地址          |accept     |recvfrom   |
|源端口号          |accept     |recvfrom   |
|目的IP地址        |getsockname|recvmsg    |
|目的端口号        |getsockname|getsockname|


#### 6. UDP的connect函数
----
**说明**：对于一个UDP套接字来说调用connect函数与TCP套接字有以下三种区别
	
 - `connect`函数不执行三次握手
 - 内核将会只检查是否存在立即可知的错误
 - 记录对端的IP地址和端口号，然后立即返回
    
**区别**：对于一个未连接的UDP套接字有以下三种区别
	 
 - 不能给输出操作指定目的IP地址和端口号，所以建议使用`write`或者`send`.如果使用`sendto`，其目的地址必须为空，大小必须为 0
 - 不必使用recvfrom来获悉数据报的发送者，所以建议使用`read`或者`recv` 或者 `recvmsg`，因为一切除了`connect`时使用的对端地址发来的数据报将不会投递给该套接字
 - 由于已连接套接字发生的异步错误将返回给应用进程

**限制**：
 
 - 由于要使用`connect`来为UDP套接字连接，所以该套接字只能与已连接的IP地址进行数据交换，这个IP地址可以使多播

#### 7. 多次调用connect函数
----
	UDP套接字的 `connect` 函数可以多次调用，TCP套接字的`connect`只能调用一次
	其调用一般出于以下两个目的：
	
- 指定新的IP地址和端口号，为一个已连接的UDP套接字指定新的对端
- 断开套接字，在新的地址组成员（`sin_family` or `sin6_family`)设置成**AF_UNSPEC**

#### 8.  client2.cpp
----
在client1.cpp中检查了recvfrom中得到的对端的地址，在client2.cpp中对此作出改进：
- 将目的IP地址和端口号形成的地址结构体作为connect的参数
- 使用write和read调用来发送和接受数据，而不是用sendto和recvfrom
- 不用检查数据是否来自于目的服务器，因为connect后的UDP套接字只接受有对端发来的数据
- 如果对方服务器未运行的情况下：
	- 使用未connect的UDP套接字向一个未运行的服务器发送（`sendto`）数据，返回一个ICMP消息端口不可达，属于异步错误，客户应用进程无法接收
	- 当UDP套接字连接后，想一个未运行的服务器发送数据，异步错误将返回个应用进程，client2.cpp在服务器未运行的情况下发送数据得到的结果将是：`read error: connection refused`

####9. UDP套接字接收缓冲区
----
在server3.cpp中用n来设置服务器接收缓冲区的大小，可以看到一下情况：
- 当接受缓冲区设置只有3 * 1024时，向服务器连续发送2000个报文，总是有即使个数据包丢失，这是由于UDP服务缺乏流量控制，过多的发送包淹没了接收缓冲区，产生了丢包
- 将接受缓冲区增大至220 * 1024时，没有产生丢包
- client3.cpp用来连续向服务器发送2000个数据报，server3.cpp只计算接受到的数据报的个数不进行应答


####10. server4.cpp
----
**使用select函数的TCP和UDP的回射服务器**：
- 设置TCP的套接字结构体地址时，使用setsockopt/SO_REUSEADDR，来使的端口可以重用
- 同样的地址用于绑定UDP的套接字，这与是否使用setsockopt/SO_REUSEADDR无关
- 在rset中只添加listenfd和udpfd两项
- 使用TCP的连接，产生一个子进程用来与之交换数据
- 使用UDP的会话，直接接收并返回数据