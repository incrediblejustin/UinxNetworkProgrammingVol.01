##套接字选项
--
####1. 影响套接字选项的函数
--
`getsockopt` 、 `setsockopt`  、`fcntl`  和`ioctl`  
 
 
####2. getsockopt 和 setsockopt
--
```cpp
	//其中sockfd必须指向一个打开套接字描述符，level(级别)指定系统中解释选项的代码或  
	//为通/用套接字代码，或为某个特定于协议的代码，optval是一个指向某个变量(*optval)  
	//的指针，setsockopt从*optval中取得选项待设置的新值，getsockopt则把已获取的  
	//选项当前值存放到*optval，*optval的大小由最后一个参数optlen指定，  
	//它对于setsockopt是一个值参数，对于getsockopt是一个值-结果参数  
	#include <sys/socket.h>  
	int getsockop(int sockfd, int level, int optname, 
	              void *optval, socklen_t *optlen);  
	  
	int setsockopt(int sockfd, int level, int optname, 
	               const void *optval, socklen_t optlen);  
```
####3. fcntl函数
--
```cpp
	//非阻塞I/O。通过使用F_SETFL命令设置O_NONBLOCK文件状态标志，我们可以把一个套接字  
	//    设置为非阻塞型  
	//信号驱动I/O。通过使用F_SETFL命令设置O_ASYNC文件状态标志，我们可以把一个套接字设  
	//    置成一旦其状态发生变化，内核就产生一个SIGIO信号  
	//F_SETOWN命令允许我们指定用于接收SIGIO和SIGURG信号的进程ID或进程组ID，。其中  
	//    SIGIO信号是套接字被设置为信号驱动式I/O型后产生的，SIGURG信号是在新的外带数据  
	//    到达套接字时产生的。  
	  
	//每种描述符(包括套接字描述符)都有一组由F_GETFL命令获取或F_SETFL命令设置  
	//的文件标志。其中影响套接字描述符的两个标志是：  
	//O_NONBLOCK--------非阻塞I/O  
	//O_ASYNC-------------信号驱动式I/O  
	#include<fcntl.h>  
	int fcntl(int fd, int cmd, ... /* int arg */ );  
```
 
####4.1 通用套接字选项
--
1. **SO_BROADCAST**
--
**作用：**本选项开启或禁用发送广播消息能力
**限制：**只有数据报套接字支持广播，并且还必须是在支持广播消息的网络上(如以太网，令牌环网等)。我们不可以在点对点链路上进行广播，也不能在基于连接的传输协议上进行广播
**使用场景：**本选项默认是未设置的，应用和进程在发送广播数据报之前必须设置这个选项，有效的防止应用进程在没有设计成可广播时就发送广播数据报

2. **SO_DEBUG**
--
**作用：**当给一个TCP套接字开启本选项时，内核将为TCP在该套接字发送和接收时的所有分组保留详细跟踪信息。
**限制：**本选项仅支持TCP
**使用场景：**这些信息保存在内核的某个环形缓冲区中，并可使用trpt程序进行检查 
 
3. **SO_DONTROUTE**
--
**作用：**本选项规定外出的分组将绕过底层协议的正常路由机制 
 
4. **SO_ERROR**
--
 - 当一个套接字上发生错误时，内核中的协议模块将该套接字的名为so_error的变量设置为标志的unix Exxx值中的一个，我们称它为该套接字的待处理错误。**内核能够以下面两种方式之一立即通知这个错误**
   
   1. 如果进程阻塞在该套接字的`select`调用上，那么无论是检查可读条件还是可写条件，`select`均返回并设置其中一个或所有两个条件
   2. 如果进程使用信号驱动式I/O模型，那就给进程或进程组产生一个SIGIO信号 
**作用：**进程可以通过访问SO_ERROR套接字选项来获取so_error的值，由`getsockopt`返回的整数值就是该套接字的待处理错误
**使用场景：**
- 如果read没有数据返回，so_error为非0，那么read返回-1，并将so_error的值赋给errno,so_error随后被复位为0
- 如果进程调用write时so_error为非0，那么write返回-1，并将so_error的值赋给errno,so_error随后被复位为0
**限制：**so_error的值再返回用户进程的时候就已经被复位为0，并且该套接字选项只可以获取，而不能设置

5. **SO_KEEPALIVE**
--
**作用：**如果两小时内在该套接字的任一方向上都没有数据交换，TCP就自动给对端发送一个keepalive探测分组，这是一个对端必须响应的TCP分组，它会导致以下三种情况

 1. 对端以期望的ACK响应，应用进程得不到通知(因为一切正常)。在经过无动静的2小时后TCP将发出另一个探测分组
 2. 对端以RST响应，它告知本端TCP，对端已崩溃且已重新启动。该套接字的待处理错误被设置为ECONNRESET，套接字本身则被关闭
 3. 对端保持存活探测分组没有任何响应，来自伯里克的TCP将另外发送8个探测分组，两两相隔75秒，试图得到一个响应，TCP在发出第一个探测分组后11分15秒内若没有得到任何响应则放弃 
 **使用场景：**
 
|情形|对端进程崩溃|对端主机崩溃|对端主机不可达|
| :-------- | :-------- | :------ |:-----|
|本端TCP正主动发送数据|对端TCP发送一个FIN，这通过使用select判断可读条件立即能检测出来。如果本端TCP发送另一个分节，对端TCP就以RST相应。如果本端在收到RST后仍是如写套接字，我们的套接字实现就给进程发送一个SIGPIPE信号|本端TCP将超时，且套接字的待处理错误被设置成ETIMEOUT|本端TCP将超时，且套接字的待处理错误被设置成EHOSTUNREACH|
|本端TCP正主动接收数据|对端TCP将发送一个FIN，我们将其作为一个过早的EOF读入|停止接收数据|停止接收数据|
|连接空闲，保持存活选项被设置|对端TCP发送一个FIN，通过使用select判断可读条件立即检测出来|在毫无动静的2小时之后发送9个保持存活的探测分节，待处理错误被设置为ETIMEOUT|在毫无动静的2小时之后发送9个保持存活的探测分节，待处理错误被设置为EHOSTUNREACH|
|连接空闲，保持存活选项没有被设置|对端TCP发送一个FIN，通过使用select判断可读条件立即检测出来|无|无|
	 
6. **`SO_LINGER`**
--
 **作用：**本选项指定close函数对面连接的协议如何操作，默认操作是close立即返回，但是如果有数据残留在套接字发送缓冲区中，系统将试着把这些数据发送给对方

```cpp
//so_linger的结构如下
#include <sys/socket.h>  
struct linger 
{  
int l_onoff;  
int l_linger  
}  
```
|函数|说明|
|:-------|:-------|
|`shutdown`, `SHUT_RD`|套接字上不能在发出接收请求<br>进程仍可以往套接字发送数据<br>套接字接受缓冲区的数据将被丢弃<br>再接收到的数据由TCP丢弃<br>对套接字发送缓冲区没有任何影响|
|`shutdown`，`SHUT_WR`|套接字上不能再发出发送请求<br>进程仍可以从套接字接收数据<br>套接字发送缓冲区的内容将被发送到对端，再发送FIN<br>对套接字的接收缓冲区没有任何影响|
|`close`，`l_onoff=0`|套接字上不能再发出发送或者接受请求<br>套接字发送缓冲区的内容被发送到对端<br>如果描述符的引用计数变成0，在发送玩发送缓冲区的数据后再发送FIN<br>套接字接受缓冲区的内容将被丢弃|
|`close`，`l_onoff=1`, `l_linger=0`|套接字上不能再发出发送或者接受请求<br>如果描述符引用计数变为0，相对端发送RST<br>将不经过TIME_WAIT状态直接变为CLOSED<br>接收和发送缓冲区的数据都将被丢弃|
|`close`，`l_onoff=1`, `l_linger!=0`|套接字上不能再发出发送或者接受请求<br>发送缓冲区的内容将被发送到对端<br>如果描述符引用计数变为0，再发送FIN<br>接收缓冲区的数据将被丢弃<br>如果连接变为CLOSED状态前，l_linger时间到，那么close返回EWOULDBLOCK|


 

7. **`SO_RCVLOWAT`和`SO_SNDLOWAT`**
--
**描述：**每个套接字还有一个接收低水位标记和一个发送低水位标记
 - 低水位标记是让select返回可读时套接字接收缓冲区中所需的数量，对于UDP和TCP默认是1
 - 发送低水位标记让select返回可写时套接字发送缓冲区中所需的可用空间，对于TCP默认是2048
 
8. **`SO_RCVTIMEO`和`SO_SNDTIMEO`**
--
**作用：**这两个选项允许我们给套接字的接收和发送设置一个超时值
**使用场景：**
- 接收超时影响的五个函数
`read`，`readv`，`recv`，`recvfrom`和`recvmsg`
- 发送超时影响的五个函数
`write`，`writev`，`send`，`sendto`，`sendmsg`
 
9. **`SO_REUSEADDR`和`SO_REUSEPORT`**
-- 
 1. SO_REUSEADDR允许启动一个监听服务器并捆绑其众所周知端口，即使以前建立的将该端口用作他们的本地端口连接仍然存在
 2. 允许在同一端口上启动同一服务器的多个实例，只要每个实例捆绑一个不同的本地IP地址即可
 3. 允许单个进程捆绑同一端口到多个套接字上，只要每次捆绑指定不同的本地IP地址即可
 4. SO_REUSEADDR允许完全重复的捆绑
 
 
 


